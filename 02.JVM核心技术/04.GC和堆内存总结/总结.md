### GC与堆内存总结

#### GC
* 串行GC
  * 单个GC线程
  * STW
  * 适用于单核机器
* 并行GC
  * 多个GC线程并行
  * STW
  * 相比于并发GC，并行GC单次停顿时间长，但GC执行次数少，吞吐量更高
  * 适合对停顿时间不敏感的场景，比如后台任务
* 并发GC（CMS、G1）
  * 初始标记和最终标记阶段需要STW，其它阶段与业务线程一起执行
  * 相比于并行GC，并发GC单次停顿时间短，但GC执行次数多，吞吐量有所下降
  * 会有浮动垃圾产生，可能退化为串行GC
  * CMS
    * 标记清除算法，会有内存碎片问题；可以通过配置参数几次GC后整理一次
    * 暂停时间不可预测
    * 适合堆内存较小的场景，比如4G、8G
  * G1
    * 将内存分为多个小的区域进行回收，优先回收垃圾多的小块
    * 还是有分代收集的思想
    * 可预测的停顿时间，可以设置最大暂停时间来控制
    * 适合堆内存大的场景，比如>=16G
* GC日志
  * 先了解GC执行流程，再去读GC日志
  * 有一些线上的工具可以辅助我们区分析GC日志


#### 堆内存
* 栈
  * xss 限制的是单个栈的大小
  * 降低 xss 大小，每个线程栈深度会变小，但栈区可创建的线程数会增加
  * 线程创建多了，栈区也会发生 OOM
* 堆
  * JVM可以根据运行情况，动态调整堆内存参数，具体调整策略还不了解
  * 年轻代
    * s区放不下存活的对象时，会进入老年代；增加young内存，避免过早提升
    * 增大年轻代的内存大小，可以降低GC的频率，但每次GC时间会增加，可以接受
  * 老年代
    * 大对象直接进入老年代，程序中避免创建朝生夕死的大对象，避免过早提升
* meta
  * 配置类可卸载可以降低 OOM 的概率
* 内存泄露（我们以为该内存回收了，但实际上没有回收）
  * 现象
    * 堆内存使用不断增加
    * 分配速率一直大于回收速率
  * 解决方法
    * jmap dump 堆内存
    * 使用相关工具分析，找到占用内存到的对象
    * 定位创建该对象的代码，排查问题